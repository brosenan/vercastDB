
    BranchStore .init(type, args) should create a new object version, and return its ID
  ․ BranchStore .init(type, args) should create a new object version, and return its ID
    BranchStore .trans(v, p, u) -> {v,r} should transform an object version according to the given patch
  ․ BranchStore .trans(v, p, u) -> {v,r} should transform an object version according to the given patch
    BranchStore .fork(b, v) should create a new branch, starting at the given version ID
  ․ BranchStore .fork(b, v) should create a new branch, starting at the given version ID
    BranchStore .head(b) should return the last known head of a branch (can be somewhat stale)
  ․ BranchStore .head(b) should return the last known head of a branch (can be somewhat stale)
    BranchStore .head(b) should fail gracefully if the branch has not been initialized
  ․ BranchStore .head(b) should fail gracefully if the branch has not been initialized
    BranchStore .push(b, v, atomic=false) should merge the changes made in v to branch b
  ․ BranchStore .push(b, v, atomic=false) should merge the changes made in v to branch b
    BranchStore .push(b, v, atomic=false) should throw an exception on a conflict
  ․ BranchStore .push(b, v, atomic=false) should throw an exception on a conflict
    BranchStore .push(b, v, atomic=false) should retry the update in case of a race with another push
  ․ BranchStore .push(b, v, atomic=false) should retry the update in case of a race with another push
    BranchStore .push(b, v, atomic=false) should commit all changes in v as a single atomic transaction if atomic is true
  ․ BranchStore .push(b, v, atomic=false) should commit all changes in v as a single atomic transaction if atomic is true
    BranchStore .pull(v, b) should return a merge between the head of b and v
  ․ BranchStore .pull(v, b) should return a merge between the head of b and v
    BranchStore .pull(v, b) should resolve conflicts by preferring the branch
  ․ BranchStore .pull(v, b) should resolve conflicts by preferring the branch
    DummyAtomicKVS as AtomicKeyValue .newKey(key, val) should store a new key/value pair, given that key does not already exist
  ․ DummyAtomicKVS as AtomicKeyValue .newKey(key, val) should store a new key/value pair, given that key does not already exist
    DummyAtomicKVS as AtomicKeyValue .newKey(key, val) should emit an error when the key already exists
  ․ DummyAtomicKVS as AtomicKeyValue .newKey(key, val) should emit an error when the key already exists
    DummyAtomicKVS as AtomicKeyValue .retrieve(key)) should emit an error if the value does not exist
  ․ DummyAtomicKVS as AtomicKeyValue .retrieve(key)) should emit an error if the value does not exist
    DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal) should change the value under key to newVal, given that the previous value was oldVal
  ․ DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal) should change the value under key to newVal, given that the previous value was oldVal
    DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal) should not change the value under key if the current value does not equal oldVal
  ․ DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal) should not change the value under key if the current value does not equal oldVal
    DummyGraphDB as GraphDB addEdge should accept an edge and add it to the graph
  ․ DummyGraphDB as GraphDB addEdge should accept an edge and add it to the graph
    DummyGraphDB as GraphDB addEdge should create a dual mapping, mapping also the destination to the source
  ․ DummyGraphDB as GraphDB addEdge should create a dual mapping, mapping also the destination to the source
    DummyGraphDB as GraphDB findCommonAncestor should find the common ancestor of two nodes, and the path to each of them
  ․ DummyGraphDB as GraphDB findCommonAncestor should find the common ancestor of two nodes, and the path to each of them
    DummyGraphDB as GraphDB findCommonAncestor should handle the case where there are also common descendants
  ․ DummyGraphDB as GraphDB findCommonAncestor should handle the case where there are also common descendants
    DummyGraphDB as GraphDB findCommonAncestor should return the path from the common ancestor to both nodes
  ․ DummyGraphDB as GraphDB findCommonAncestor should return the path from the common ancestor to both nodes
    DummyGraphDB .findPath(x, y, cb(err, path)) should return the labels along the edges from x to y
  ․ DummyGraphDB .findPath(x, y, cb(err, path)) should return the labels along the edges from x to y
    DummyGraphDB .findPath(x, y, cb(err, path)) should always take the shortest path
  ․ DummyGraphDB .findPath(x, y, cb(err, path)) should always take the shortest path
    DummyGraphDB .findPath(x, y, cb(err, path)) should handle directed cycles correctly
  ․ DummyGraphDB .findPath(x, y, cb(err, path)) should handle directed cycles correctly
    DummyKeyValueStore should retrieve stored values
  ․ DummyKeyValueStore should retrieve stored values
    DummyObjectStore .init(type, args) should return a version ID of a newly created object
  ․ DummyObjectStore .init(type, args) should return a version ID of a newly created object
    DummyObjectStore .trans(v, p, u) -> {v, r, eff} should return the value returned from the method corresponding to patch p
  ․ DummyObjectStore .trans(v, p, u) -> {v, r, eff} should return the value returned from the method corresponding to patch p
    DummyObjectStore .trans(v, p, u) -> {v, r, eff} should pass the patch and u flag as parameters to the called method
  ․ DummyObjectStore .trans(v, p, u) -> {v, r, eff} should pass the patch and u flag as parameters to the called method
    DummyObjectStore .trans(v, p, u) -> {v, r, eff} should replace the object with another if replaced with its ID
  ․ DummyObjectStore .trans(v, p, u) -> {v, r, eff} should replace the object with another if replaced with its ID
    DummyObjectStore context .init(type, args) should initialize an object with the given type and args and return its version ID
  ․ DummyObjectStore context .init(type, args) should initialize an object with the given type and args and return its version ID
    DummyObjectStore context .trans(v, p, u) -> {v,r,eff} should transform a version and return the new version ID and result
  ․ DummyObjectStore context .trans(v, p, u) -> {v,r,eff} should transform a version and return the new version ID and result
    DummyObjectStore context .conflict(msg) should throw an exception with .isConflict set to true
  ․ DummyObjectStore context .conflict(msg) should throw an exception with .isConflict set to true
    DummyObjectStore context .effect(p) should add patch p to the effect sequence
  ․ DummyObjectStore context .effect(p) should add patch p to the effect sequence
    DummyObjectStore context .effect(p) should add patches to the effect set even when called from a nested transformation
  ․ DummyObjectStore context .effect(p) should add patches to the effect set even when called from a nested transformation
    DummyObjectStore context .self() should return the version ID of the object prior to this patch application
  ․ DummyObjectStore context .self() should return the version ID of the object prior to this patch application
    DummyObjectStore .addTransListener(handler(v1, p, u, v2, r, eff)) should call the handler on each successful call to trans()
  ․ DummyObjectStore .addTransListener(handler(v1, p, u, v2, r, eff)) should call the handler on each successful call to trans()
    EventuallyConsistentKVS .newKey(key, value) should store a new key/value pair given that the method is called only once for that key
  ․ EventuallyConsistentKVS .newKey(key, value) should store a new key/value pair given that the method is called only once for that key
    EventuallyConsistentKVS .retrieve(key) should return a previously-assigned value of the key, or undefined the value has not yet been regiested
  ․ EventuallyConsistentKVS .retrieve(key) should return a previously-assigned value of the key, or undefined the value has not yet been regiested
    EventuallyConsistentKVS .modify(key, value) should change the value so that it eventually becomes the given one
  ․ EventuallyConsistentKVS .modify(key, value) should change the value so that it eventually becomes the given one
    $inv should unapply the underlying patch
  ․ $inv should unapply the underlying patch
    MergingObjectStore .init(type, args) should return a new version ID
  ․ MergingObjectStore .init(type, args) should return a new version ID
    MergingObjectStore .trans(v, p) -> {v,r} should apply a patch to the state
  ․ MergingObjectStore .trans(v, p) -> {v,r} should apply a patch to the state
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should return the merged version of both v1 and v2
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should return the merged version of both v1 and v2
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should record each merge so that further merges can be performed
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should record each merge so that further merges can be performed
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should fail on conflict, if resolve === false or omitted
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should fail on conflict, if resolve === false or omitted
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should pass if resolve === true, preferring v1
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should pass if resolve === true, preferring v1
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should record the merge in such a way that will preserve the resolution decisions
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should record the merge in such a way that will preserve the resolution decisions
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should record each patch by itself when atomic is false or omitted
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should record each patch by itself when atomic is false or omitted
    MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should bundle all patches contributed by a merge in a single transaction, if atomic is true
  ․ MergingObjectStore .merge(v1, v2, resolve=false, atomic=false) should bundle all patches contributed by a merge in a single transaction, if atomic is true
    ObjectDispatcher .init(type, args) should return an instance of the referenced type, after calling the init() function associated with the type
  ․ ObjectDispatcher .init(type, args) should return an instance of the referenced type, after calling the init() function associated with the type
    ObjectDispatcher .apply(ctx, obj, patch, unapply) should call a method corresponding to patch._type
  ․ ObjectDispatcher .apply(ctx, obj, patch, unapply) should call a method corresponding to patch._type
    ObjectDispatcher .apply(ctx, obj, patch, unapply) should call a patch handler function if one exists in the map
  ․ ObjectDispatcher .apply(ctx, obj, patch, unapply) should call a patch handler function if one exists in the map
    ObjectDispatcher .apply(ctx, obj, patch, unapply) should prefer the object method when both a method and a handler are defined
  ․ ObjectDispatcher .apply(ctx, obj, patch, unapply) should prefer the object method when both a method and a handler are defined
    ObjectDispatcher .apply(ctx, obj, patch, unapply) should call the object's _default() method if it exists and a specific handler is not defined
  ․ ObjectDispatcher .apply(ctx, obj, patch, unapply) should call the object's _default() method if it exists and a specific handler is not defined
    ObjectDispatcher .apply(ctx, obj, patch, unapply) should prefer a class method over _default
  ․ ObjectDispatcher .apply(ctx, obj, patch, unapply) should prefer a class method over _default
    ObjectDispatcher .apply(ctx, obj, patch, unapply) should prefer a generic handler over _default
  ․ ObjectDispatcher .apply(ctx, obj, patch, unapply) should prefer a generic handler over _default
    ObjectMonitor .proxy() should allow modifying an object through a proxy
  ․ ObjectMonitor .proxy() should allow modifying an object through a proxy
    ObjectMonitor .proxy() should wrap objects (including arrays) with map proxies
  ․ ObjectMonitor .proxy() should wrap objects (including arrays) with map proxies
    ObjectMonitor .proxy() should provide access to child object fields via get/put methods, that update the dirty flag
  ․ ObjectMonitor .proxy() should provide access to child object fields via get/put methods, that update the dirty flag
    ObjectMonitor .proxy() should retain the original object as a simple, JSON-style object
  ․ ObjectMonitor .proxy() should retain the original object as a simple, JSON-style object
    ObjectMonitor .proxy() should use map proxies recursively
  ․ ObjectMonitor .proxy() should use map proxies recursively
    ObjectMonitor .proxy() should return an unextensible proxy object
  ․ ObjectMonitor .proxy() should return an unextensible proxy object
    ObjectMonitor .proxy() should not provide a map proxy for id-like objects
  ․ ObjectMonitor .proxy() should not provide a map proxy for id-like objects
    ObjectMonitor .proxy() should not provide a map proxy for id-like nested objects
  ․ ObjectMonitor .proxy() should not provide a map proxy for id-like nested objects
    ObjectMonitor .proxy() ._replaceWith(obj) should replace the underlying object with the given one
  ․ ObjectMonitor .proxy() ._replaceWith(obj) should replace the underlying object with the given one
    ObjectMonitor .isDirty() should indicate if a change to the object has been made since the last time it has been called
  ․ ObjectMonitor .isDirty() should indicate if a change to the object has been made since the last time it has been called
    ObjectMonitor .hash() should return a unique string representing the content of the object
  ․ ObjectMonitor .hash() should return a unique string representing the content of the object
    ObjectMonitor .hash() should work regardless of dirty testing
  ․ ObjectMonitor .hash() should work regardless of dirty testing
    ObjectMonitor .seal(obj) [static] should make the given object unmodifiable
  ․ ObjectMonitor .seal(obj) [static] should make the given object unmodifiable
    ObjectMonitor .seal(obj) [static] should place the object's hash as the $ property of the object
  ․ ObjectMonitor .seal(obj) [static] should place the object's hash as the $ property of the object
    ObjectMonitor .seal(obj) [static] should return the hash
  ․ ObjectMonitor .seal(obj) [static] should return the hash
    ObjectMonitor .seal(obj) [static] should allow an object to be sealed multiple times
  ․ ObjectMonitor .seal(obj) [static] should allow an object to be sealed multiple times
    ObjectMonitor .revision() should return the object's revision number, one that icrements with each change
  ․ ObjectMonitor .revision() should return the object's revision number, one that icrements with each change
    ObjectMonitor .json() should return a JSON representation of the object
  ․ ObjectMonitor .json() should return a JSON representation of the object
    ObjectMonitor .object() should provide an unprovisioned access to the object
  ․ ObjectMonitor .object() should provide an unprovisioned access to the object
    ObjectTestBed .trans(p) should apply a patch, returning the result
  ․ ObjectTestBed .trans(p) should apply a patch, returning the result
    ObjectTestBed .trans(p) reversibilityChecker should fail for non-reversible transformations
  ․ ObjectTestBed .trans(p) reversibilityChecker should fail for non-reversible transformations
    ObjectTestBed .trans(p) reversibilityChecker should consult a digest() method (if defined) to get a representation of the value
  ․ ObjectTestBed .trans(p) reversibilityChecker should consult a digest() method (if defined) to get a representation of the value
    ObjectTestBed .trans(p) commutativityChecker should fail for independent transformations that do not commute
  ․ ObjectTestBed .trans(p) commutativityChecker should fail for independent transformations that do not commute
    ObjectTestBed .trans(p) commutativityChecker should not fail when the transformations are not independent
  ․ ObjectTestBed .trans(p) commutativityChecker should not fail when the transformations are not independent
    ObjectTestBed .trans(p) commutativityChecker should fail when for independent p1 and p2, one permutation conflicts
  ․ ObjectTestBed .trans(p) commutativityChecker should fail when for independent p1 and p2, one permutation conflicts
    ObjectTestBed .trans(p) commutativityChecker should fail on non-commutative independent patches even if p1 and p2 are not following one anotherp
  ․ ObjectTestBed .trans(p) commutativityChecker should fail on non-commutative independent patches even if p1 and p2 are not following one anotherp
    ObjectTestBed .trans(p) commutativityChecker should consult a digest() method (if exists) to determine version equivalence
  ․ ObjectTestBed .trans(p) commutativityChecker should consult a digest() method (if exists) to determine version equivalence
    RootStore .init(type, args) should return an initial version ID of a new object
  ․ RootStore .init(type, args) should return an initial version ID of a new object
    RootStore .trans(v, p, u) -> {v,r} should call a patch method and return its returned value
  ․ RootStore .trans(v, p, u) -> {v,r} should call a patch method and return its returned value
    RootStore .trans(v, p, u) -> {v,r} should apply the effect set internally
  ․ RootStore .trans(v, p, u) -> {v,r} should apply the effect set internally
    RootStore .trans(v, p, u) -> {v,r} should return the return value of the original patch
  ․ RootStore .trans(v, p, u) -> {v,r} should return the return value of the original patch
    SequenceStoreFactory .createSequenceStore() should return a new sequence store
  ․ SequenceStoreFactory .createSequenceStore() should return a new sequence store
    SequenceStoreFactory .createSequenceStore() .append(obj) should append an object to a sequence
  ․ SequenceStoreFactory .createSequenceStore() .append(obj) should append an object to a sequence
    SequenceStoreFactory .createSequenceStore() .append(obj) should append an entire sequence if given its hash
  ․ SequenceStoreFactory .createSequenceStore() .append(obj) should append an entire sequence if given its hash
    SequenceStoreFactory .createSequenceStore() .append(obj) should append a sequence consisting of a single object when given its hash
  ․ SequenceStoreFactory .createSequenceStore() .append(obj) should append a sequence consisting of a single object when given its hash
    SequenceStoreFactory .createSequenceStore() .isEmpty() should indicate if the sequence is empty
  ․ SequenceStoreFactory .createSequenceStore() .isEmpty() should indicate if the sequence is empty
    SequenceStoreFactory .createSequenceStore() .shift() should remove the first element from the sequence and return it
  ․ SequenceStoreFactory .createSequenceStore() .shift() should remove the first element from the sequence and return it
    SequenceStoreFactory .createSequenceStore() .pop() should remove the last element from the sequence and return it
  ․ SequenceStoreFactory .createSequenceStore() .pop() should remove the last element from the sequence and return it
    SequenceStoreFactory .createSequenceStore() .hash() should return an empty string if the sequence is empty
  ․ SequenceStoreFactory .createSequenceStore() .hash() should return an empty string if the sequence is empty
    SequenceStoreFactory .createSequenceStore() .hash() should return the object hash, assuming only one object in the sequence
  ․ SequenceStoreFactory .createSequenceStore() .hash() should return the object hash, assuming only one object in the sequence
    SequenceStoreFactory .createSequenceStore() .hash() should return a hash unique to the sequence for sequence size larger than 1
  ․ SequenceStoreFactory .createSequenceStore() .hash() should return a hash unique to the sequence for sequence size larger than 1
    SequenceStoreFactory .createSequenceStore() .hash() should provide the same hash if the only element in a sequence is a hash of another sequence
  ․ SequenceStoreFactory .createSequenceStore() .hash() should provide the same hash if the only element in a sequence is a hash of another sequence
    SimpleObjectStore should avoid running the patch method again if the patch has already been applied on an identical object
  ․ SimpleObjectStore should avoid running the patch method again if the patch has already been applied on an identical object
    SimpleObjectStore .init(type, args) should return a version ID of a newly created object
  ․ SimpleObjectStore .init(type, args) should return a version ID of a newly created object
    SimpleObjectStore .trans(v, p, u) -> {v, r, eff} should return the value returned from the method corresponding to patch p
  ․ SimpleObjectStore .trans(v, p, u) -> {v, r, eff} should return the value returned from the method corresponding to patch p
    SimpleObjectStore .trans(v, p, u) -> {v, r, eff} should pass the patch and u flag as parameters to the called method
  ․ SimpleObjectStore .trans(v, p, u) -> {v, r, eff} should pass the patch and u flag as parameters to the called method
    SimpleObjectStore .trans(v, p, u) -> {v, r, eff} should replace the object with another if replaced with its ID
  ․ SimpleObjectStore .trans(v, p, u) -> {v, r, eff} should replace the object with another if replaced with its ID
    SimpleObjectStore context .init(type, args) should initialize an object with the given type and args and return its version ID
  ․ SimpleObjectStore context .init(type, args) should initialize an object with the given type and args and return its version ID
    SimpleObjectStore context .trans(v, p, u) -> {v,r,eff} should transform a version and return the new version ID and result
  ․ SimpleObjectStore context .trans(v, p, u) -> {v,r,eff} should transform a version and return the new version ID and result
    SimpleObjectStore context .conflict(msg) should throw an exception with .isConflict set to true
  ․ SimpleObjectStore context .conflict(msg) should throw an exception with .isConflict set to true
    SimpleObjectStore context .effect(p) should add patch p to the effect sequence
  ․ SimpleObjectStore context .effect(p) should add patch p to the effect sequence
    SimpleObjectStore context .effect(p) should add patches to the effect set even when called from a nested transformation
  ․ SimpleObjectStore context .effect(p) should add patches to the effect set even when called from a nested transformation
    SimpleObjectStore context .self() should return the version ID of the object prior to this patch application
  ․ SimpleObjectStore context .self() should return the version ID of the object prior to this patch application
    SimpleQueue should retrieve elements in the same order they were entered
  ․ SimpleQueue should retrieve elements in the same order they were entered
    SimpleVersionGraph .recordTrans(v1, p, v2) should return a callback with no error if all is OK
  ․ SimpleVersionGraph .recordTrans(v1, p, v2) should return a callback with no error if all is OK
    SimpleVersionGraph .getMergeStrategy(v1, v2) should return x as the common ancestor of v1 and v2
  ․ SimpleVersionGraph .getMergeStrategy(v1, v2) should return x as the common ancestor of v1 and v2
    SimpleVersionGraph .getMergeStrategy(v1, v2) should return either v1 or v2 as V1, and the other as V2
  ․ SimpleVersionGraph .getMergeStrategy(v1, v2) should return either v1 or v2 as V1, and the other as V2
    SimpleVersionGraph .getMergeStrategy(v1, v2) should set V1 and V2 to be v1 and v2 respectively if resolve=true
  ․ SimpleVersionGraph .getMergeStrategy(v1, v2) should set V1 and V2 to be v1 and v2 respectively if resolve=true
    SimpleVersionGraph .recordMerge(mergeInfo, newV, p1, p2) should record a merge using the mergeInfo object obtained from getMergeStrategy(), and a merged version
  ․ SimpleVersionGraph .recordMerge(mergeInfo, newV, p1, p2) should record a merge using the mergeInfo object obtained from getMergeStrategy(), and a merged version
    SimpleVersionGraph .appendPatchesTo(mergeInfo, seq, taken) should append all the labels along the path from x to V2 to the given sequence, if taken is true
  ․ SimpleVersionGraph .appendPatchesTo(mergeInfo, seq, taken) should append all the labels along the path from x to V2 to the given sequence, if taken is true
    SimpleVersionGraph .appendPatchesTo(mergeInfo, seq, taken) should append all the labels along the path from x to V1 to the given sequence, if taken is false
  ․ SimpleVersionGraph .appendPatchesTo(mergeInfo, seq, taken) should append all the labels along the path from x to V1 to the given sequence, if taken is false
    $transaction should apply all patches enclosed in the hash that it holds as a single transaction
  ․ $transaction should apply all patches enclosed in the hash that it holds as a single transaction
    array should apply patches to different objects, by the patch's _key attribute
  ․ array should apply patches to different objects, by the patch's _key attribute
    atom should allow setting and getting a value
  ․ atom should allow setting and getting a value
    counter should add the given amount to the counter and return the value
  ․ counter should add the given amount to the counter and return the value

  121 passing (404ms)

